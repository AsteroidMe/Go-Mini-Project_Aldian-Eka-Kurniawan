
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">eco-journal/config/database.go (0.0%)</option>
				
				<option value="file1">eco-journal/config/migrate.go (0.0%)</option>
				
				<option value="file2">eco-journal/controller/author_controller.go (0.0%)</option>
				
				<option value="file3">eco-journal/controller/category_controller.go (0.0%)</option>
				
				<option value="file4">eco-journal/controller/chat_controller.go (0.0%)</option>
				
				<option value="file5">eco-journal/controller/journal_controller.go (0.0%)</option>
				
				<option value="file6">eco-journal/controller/user_controller.go (0.0%)</option>
				
				<option value="file7">eco-journal/main.go (0.0%)</option>
				
				<option value="file8">eco-journal/middleware/auth.go (0.0%)</option>
				
				<option value="file9">eco-journal/middleware/auth_middleware.go (0.0%)</option>
				
				<option value="file10">eco-journal/middleware/jwt.go (0.0%)</option>
				
				<option value="file11">eco-journal/repository/author_repository.go (0.0%)</option>
				
				<option value="file12">eco-journal/repository/category_repository.go (0.0%)</option>
				
				<option value="file13">eco-journal/repository/chat_repository.go (0.0%)</option>
				
				<option value="file14">eco-journal/repository/journal_repository.go (0.0%)</option>
				
				<option value="file15">eco-journal/repository/mocks/author_repository_mock.go (100.0%)</option>
				
				<option value="file16">eco-journal/repository/mocks/category_repository_mock.go (100.0%)</option>
				
				<option value="file17">eco-journal/repository/user_repository.go (0.0%)</option>
				
				<option value="file18">eco-journal/route/route.go (0.0%)</option>
				
				<option value="file19">eco-journal/service/author_service.go (85.7%)</option>
				
				<option value="file20">eco-journal/service/category_service.go (85.7%)</option>
				
				<option value="file21">eco-journal/service/chat_service.go (0.0%)</option>
				
				<option value="file22">eco-journal/service/journal_service.go (0.0%)</option>
				
				<option value="file23">eco-journal/service/user_service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "log"
        "os"

        "github.com/joho/godotenv"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

var DB *gorm.DB

func LoadEnv() <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Error loading .env file")
                panic("failed to load env")</span>
        }
}

func ConnectDB() *gorm.DB <span class="cov0" title="0">{
        LoadEnv()

        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",
                os.Getenv("DB_USERNAME"),
                os.Getenv("DB_PASSWORD"),
                os.Getenv("DB_HOST"),
                os.Getenv("DB_PORT"),
                os.Getenv("DB_NAME"),
        )

        var err error
        DB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to connect to database:", err)
                panic("Database not connected")</span>
        }

        <span class="cov0" title="0">fmt.Println("Database connected successfully")
        return DB</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "eco-journal/entities"
        "fmt"
)

func MigrateDB() <span class="cov0" title="0">{
        if DB == nil </span><span class="cov0" title="0">{
                panic("Database connection not initialized")</span>
        }

        <span class="cov0" title="0">err := DB.AutoMigrate(&amp;entities.User{}, &amp;entities.Journal{}, &amp;entities.Author{}, &amp;entities.Category{}, &amp;entities.Chat{})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to migrate database:", err)
                panic("Database migration failed")</span>
        }

        <span class="cov0" title="0">fmt.Println("Database migration completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "eco-journal/entities"
        "eco-journal/service"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

type AuthorController struct {
        authorService service.AuthorServiceInterface
}

func NewAuthorController(authorService service.AuthorServiceInterface) *AuthorController <span class="cov0" title="0">{
        return &amp;AuthorController{authorService}
}</span>

func (ac *AuthorController) Create(c *gin.Context) <span class="cov0" title="0">{
        var author entities.Author
        if err := c.ShouldBindJSON(&amp;author); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">createdAuthor, err := ac.authorService.Create(&amp;author)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "message": "Author added successfully",
                "data":    createdAuthor,
        })</span>
}

func (ac *AuthorController) Update(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">var author entities.Author
        if err := c.ShouldBindJSON(&amp;author); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">existingAuthor, err := ac.authorService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Author not found"})
                return
        }</span>

        <span class="cov0" title="0">author.ID = existingAuthor.ID

        updatedAuthor, err := ac.authorService.Update(&amp;author)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Author update successfully",
                "data":    updatedAuthor,
        })</span>
}

func (ac *AuthorController) Delete(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">author, err := ac.authorService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Author not found"})
                return
        }</span>

        <span class="cov0" title="0">err = ac.authorService.Delete(author.ID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Author deleted successfully"})</span>
}

func (ac *AuthorController) GetAll(c *gin.Context) <span class="cov0" title="0">{
        pageStr := c.Param("page")
        limitStr := c.Query("limit")

        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">authors, pagination, err := ac.authorService.GetAll(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "pagination": pagination,
                "data":       authors,
        })</span>
}

func (ac *AuthorController) GetDetails(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">author, err := ac.authorService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Author not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": author})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "eco-journal/entities"
        "eco-journal/service"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

type CategoryController struct {
        categoryService service.CategoryServiceInterface
}

func NewCategoryController(categoryService service.CategoryServiceInterface) *CategoryController <span class="cov0" title="0">{
        return &amp;CategoryController{categoryService}
}</span>

func (cc *CategoryController) Create(c *gin.Context) <span class="cov0" title="0">{
        var category entities.Category
        if err := c.ShouldBindJSON(&amp;category); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">createdCategory, err := cc.categoryService.Create(&amp;category)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "message": "Category added successfully",
                "data":    createdCategory,
        })</span>
}

func (cc *CategoryController) Update(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">var category entities.Category
        if err := c.ShouldBindJSON(&amp;category); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">existingCategory, err := cc.categoryService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Category not found"})
                return
        }</span>

        <span class="cov0" title="0">category.ID = existingCategory.ID

        updatedCategory, err := cc.categoryService.Update(&amp;category)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Category update successfully",
                "data":    updatedCategory,
        })</span>
}

func (cc *CategoryController) Delete(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">category, err := cc.categoryService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Category not found"})
                return
        }</span>

        <span class="cov0" title="0">err = cc.categoryService.Delete(category.ID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Category deleted successfully"})</span>
}

func (cc *CategoryController) GetAll(c *gin.Context) <span class="cov0" title="0">{
        pageStr := c.Param("page")
        limitStr := c.Query("limit")

        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">categories, pagination, err := cc.categoryService.GetAll(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "pagination": pagination,
                "data":       categories,
        })</span>
}

func (cc *CategoryController) GetDetails(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">category, err := cc.categoryService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Category not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": category})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "eco-journal/service"
        "net/http"

        "github.com/gin-gonic/gin"
)

type ChatController struct {
        chatService service.ChatServiceInterface
}

func NewChatController(chatService service.ChatServiceInterface) *ChatController <span class="cov0" title="0">{
        return &amp;ChatController{chatService}
}</span>

func (ctc *ChatController) ChatController(c *gin.Context) <span class="cov0" title="0">{
        var input struct {
                UserInput string `json:"user_input"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"status": false, "message": "Input Data Invalid"})
                return
        }</span>
        <span class="cov0" title="0">chat, err := ctc.chatService.ProccessChat(input.UserInput)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"status": false, "message": "Server error"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": true, "message": chat})</span>
}

func (ctc *ChatController) GetAllChats(c *gin.Context) <span class="cov0" title="0">{
        chats, err := ctc.chatService.GetAllChats()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": true, "message": chats})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "eco-journal/entities"
        "eco-journal/service"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

type JournalController struct {
        journalService service.JournalServiceInterface
}

func NewJournalController(journalService service.JournalServiceInterface) *JournalController <span class="cov0" title="0">{
        return &amp;JournalController{journalService}
}</span>

func (jc *JournalController) Create(c *gin.Context) <span class="cov0" title="0">{
        var journal entities.Journal
        if err := c.ShouldBindJSON(&amp;journal); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">author, err := jc.journalService.GetAuthorByID(journal.AuthorID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Author ID"})
                return
        }</span>

        <span class="cov0" title="0">category, err := jc.journalService.GetCategoryByID(journal.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Category ID"})
                return
        }</span>

        <span class="cov0" title="0">createdJournal, err := jc.journalService.Create(&amp;journal)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">createdJournal.Author = *author
        createdJournal.Category = *category

        c.JSON(http.StatusCreated, gin.H{
                "message": "Journal added successfully",
                "data":    createdJournal,
        })</span>
}

func (jc *JournalController) Update(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">var journal entities.Journal
        if err := c.ShouldBindJSON(&amp;journal); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">existingJournal, err := jc.journalService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Journal not found"})
                return
        }</span>

        <span class="cov0" title="0">journal.ID = existingJournal.ID

        author, err := jc.journalService.GetAuthorByID(journal.AuthorID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Author ID"})
                return
        }</span>

        <span class="cov0" title="0">category, err := jc.journalService.GetCategoryByID(journal.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Category ID"})
                return
        }</span>

        <span class="cov0" title="0">updatedJournal, err := jc.journalService.Update(&amp;journal)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">updatedJournal.Author = *author
        updatedJournal.Category = *category

        c.JSON(http.StatusOK, gin.H{
                "message": "Journal update successfully",
                "data":    updatedJournal,
        })</span>
}

func (jc *JournalController) Delete(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">journal, err := jc.journalService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Category not found"})
                return
        }</span>

        <span class="cov0" title="0">err = jc.journalService.Delete(journal.ID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Journal deleted successfully"})</span>
}

func (jc *JournalController) GetAll(c *gin.Context) <span class="cov0" title="0">{
        pageStr := c.Query("page")
        limitStr := c.Query("limit")

        page, err := strconv.Atoi(pageStr)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">journals, err := jc.journalService.GetAll(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">totalItems, err := jc.journalService.Count()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">totalPages := int((totalItems + int64(limit) - 1) / int64(limit))

        c.JSON(http.StatusOK, gin.H{
                "pagination": entities.Pagination{
                        CurrentPage: page,
                        TotalPages:  totalPages,
                        TotalItems:  totalItems,
                },
                "data": journals,
        })</span>
}

func (jc *JournalController) GetDetails(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")
        uintID, err := strconv.ParseUint(id, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">journal, err := jc.journalService.FindByID(uint(uintID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Journal not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"data": journal})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "eco-journal/entities"
        "eco-journal/service"
        "net/http"

        "github.com/gin-gonic/gin"
)

type UserController struct {
        userService service.UserServiceInterface
}

func NewUserController(userService service.UserServiceInterface) *UserController <span class="cov0" title="0">{
        return &amp;UserController{userService}
}</span>

func (uc *UserController) Register(c *gin.Context) <span class="cov0" title="0">{
        var user entities.User
        if err := c.ShouldBindJSON(&amp;user); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, entities.Response{
                        Meta: entities.Meta{
                                Status:  false,
                                Message: "Failed input data: " + err.Error(),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">if user.Email == "" || user.Password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, entities.Response{
                        Meta: entities.Meta{
                                Status:  false,
                                Message: "Fill email and password",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">createdUser, err := uc.userService.Register(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, entities.Response{
                        Meta: entities.Meta{
                                Status:  false,
                                Message: "Register failed: " + err.Error(),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, entities.Response{
                Meta: entities.Meta{
                        Status:  true,
                        Message: "Register success",
                },
                Data: createdUser,
        })</span>
}

func (uc *UserController) Login(c *gin.Context) <span class="cov0" title="0">{
        var user entities.User
        if err := c.ShouldBindJSON(&amp;user); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, entities.Response{
                        Meta: entities.Meta{
                                Status:  false,
                                Message: "Failed input data: " + err.Error(),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">if user.Email == "" || user.Password == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, entities.Response{
                        Meta: entities.Meta{
                                Status:  false,
                                Message: "Fill email and password",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">token, err := uc.userService.Login(user.Email, user.Password)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, entities.Response{
                        Meta: entities.Meta{
                                Status:  false,
                                Message: "Invalid credentials: " + err.Error(),
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">cookie := &amp;http.Cookie{
                Name:     "token",
                Value:    token,
                Path:     "/",
                HttpOnly: true,
        }
        http.SetCookie(c.Writer, cookie)

        c.JSON(http.StatusOK, entities.Response{
                Meta: entities.Meta{
                        Status:  true,
                        Message: "Login success",
                },
                Data: map[string]string{"token": token},
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "eco-journal/config"
        "eco-journal/controller"
        "eco-journal/repository"
        "eco-journal/route"
        "eco-journal/service"
        "log"
)

func main() <span class="cov0" title="0">{
        config.ConnectDB()
        config.MigrateDB()

        userRepo := repository.NewUserRepository(config.DB)
        userService := service.NewUserService(userRepo)
        userController := controller.NewUserController(userService)

        authorRepo := repository.NewAuthorRepository(config.DB)
        authorService := service.NewAuthorService(authorRepo)
        authorController := controller.NewAuthorController(authorService)

        categoryRepo := repository.NewCategoryRepository(config.DB)
        categoryService := service.NewCategoryService(categoryRepo)
        categoryController := controller.NewCategoryController(categoryService)

        journalRepo := repository.NewJournalRepository(config.DB)
        journalService := service.NewJournalService(journalRepo)
        journalController := controller.NewJournalController(journalService)

        chatRepo := repository.NewChatRepository(config.DB)
        chatService := service.NewChatService(chatRepo)
        chatController := controller.NewChatController(chatService)

        r := route.SetupRouter(userController, authorController, categoryController, journalController, chatController)
        if err := r.Run(":8000"); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server Run Failed:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

func LoginHandler(c *gin.Context) <span class="cov0" title="0">{
        var json struct {
                Username string
        }

        if err := c.ShouldBindJSON(&amp;json); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
                return
        }</span>

        <span class="cov0" title="0">token, err := GenerateToken(json.Username)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"token": token})</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

func AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header is required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
                if token == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Token is required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">claims, err := ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("claims", claims)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "time"

        "github.com/golang-jwt/jwt/v4"
)

var jwtSecret = []byte("123abc")

type Claims struct {
        Username string
        jwt.RegisteredClaims
}

func GenerateToken(username string) (string, error) <span class="cov0" title="0">{
        expirationTime := time.Now().Add(24 * time.Hour)
        claims := &amp;Claims{
                Username: username,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtSecret)
}</span>

func ValidateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        claims := &amp;Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return jwtSecret, nil
        }</span>)
        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import (
        "eco-journal/entities"

        "gorm.io/gorm"
)

type AuthorRepoInterface interface {
        Create(author *entities.Author) (*entities.Author, error)
        Update(author *entities.Author) (*entities.Author, error)
        Delete(id uint) error
        FindAll(authors *[]entities.Author, page, limit int) error
        FindByID(id uint) (*entities.Author, error)
        Count() (int64, error)
}

type authorRepository struct {
        db *gorm.DB
}

func NewAuthorRepository(db *gorm.DB) *authorRepository <span class="cov0" title="0">{
        return &amp;authorRepository{db}
}</span>

func (r *authorRepository) Create(author *entities.Author) (*entities.Author, error) <span class="cov0" title="0">{
        if err := r.db.Create(author).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return author, nil</span>
}

func (r *authorRepository) Update(author *entities.Author) (*entities.Author, error) <span class="cov0" title="0">{
        if err := r.db.Save(author).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return author, nil</span>
}

func (r *authorRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;entities.Author{}, id).Error
}</span>

func (r *authorRepository) FindAll(authors *[]entities.Author, page, limit int) error <span class="cov0" title="0">{
        offset := (page - 1) * limit
        return r.db.Offset(offset).Limit(limit).Find(authors).Error
}</span>

func (r *authorRepository) FindByID(id uint) (*entities.Author, error) <span class="cov0" title="0">{
        var author entities.Author
        if err := r.db.First(&amp;author, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;author, nil</span>
}

func (r *authorRepository) Count() (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.db.Model(&amp;entities.Author{}).Count(&amp;total).Error
        return total, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "eco-journal/entities"

        "gorm.io/gorm"
)

type CategoryRepoInterface interface {
        Create(category *entities.Category) (*entities.Category, error)
        Update(category *entities.Category) (*entities.Category, error)
        Delete(id uint) error
        FindAll(categories *[]entities.Category, page, limit int) error
        FindByID(id uint) (*entities.Category, error)
        Count() (int64, error)
}

type categoryRepository struct {
        db *gorm.DB
}

func NewCategoryRepository(db *gorm.DB) *categoryRepository <span class="cov0" title="0">{
        return &amp;categoryRepository{db}
}</span>

func (r *categoryRepository) Create(category *entities.Category) (*entities.Category, error) <span class="cov0" title="0">{
        if err := r.db.Create(category).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return category, nil</span>
}

func (r *categoryRepository) Update(category *entities.Category) (*entities.Category, error) <span class="cov0" title="0">{
        if err := r.db.Save(category).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return category, nil</span>
}

func (r *categoryRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;entities.Category{}, id).Error
}</span>

func (r *categoryRepository) FindAll(categories *[]entities.Category, page, limit int) error <span class="cov0" title="0">{
        offset := (page - 1) * limit
        return r.db.Offset(offset).Limit(limit).Find(categories).Error
}</span>

func (r *categoryRepository) FindByID(id uint) (*entities.Category, error) <span class="cov0" title="0">{
        var category entities.Category
        if err := r.db.First(&amp;category, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;category, nil</span>
}

func (r *categoryRepository) Count() (int64, error) <span class="cov0" title="0">{
        var total int64
        err := r.db.Model(&amp;entities.Category{}).Count(&amp;total).Error
        return total, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "eco-journal/entities"

        "gorm.io/gorm"
)

type ChatRepoInterface interface {
        SaveChat(chat entities.Chat) error
        GetAllChat() ([]entities.Chat, error)
}

type chatRepository struct {
        db *gorm.DB
}

func NewChatRepository(db *gorm.DB) *chatRepository <span class="cov0" title="0">{
        return &amp;chatRepository{db}
}</span>

func (r *chatRepository) SaveChat(chat entities.Chat) error <span class="cov0" title="0">{
        return r.db.Debug().Create(&amp;chat).Error
}</span>

func (r *chatRepository) GetAllChat() ([]entities.Chat, error) <span class="cov0" title="0">{
        var chats []entities.Chat
        err := r.db.Find(&amp;chats).Error
        return chats, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "eco-journal/entities"

        "gorm.io/gorm"
)

type JournalRepoInterface interface {
        Create(journal *entities.Journal) (*entities.Journal, error)
        Update(journal *entities.Journal) (*entities.Journal, error)
        Delete(id uint) error
        FindAll(page int, limit int) ([]entities.Journal, error)
        FindByID(id uint) (*entities.Journal, error)
        GetAuthorByID(id uint) (*entities.Author, error)
        GetCategoryByID(id uint) (*entities.Category, error)
        Count() (int64, error)
}

type journalRepository struct {
        db *gorm.DB
}

func NewJournalRepository(db *gorm.DB) *journalRepository <span class="cov0" title="0">{
        return &amp;journalRepository{db}
}</span>

func (r *journalRepository) Create(journal *entities.Journal) (*entities.Journal, error) <span class="cov0" title="0">{
        if err := r.db.Create(journal).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return journal, nil</span>
}

func (r *journalRepository) Update(journal *entities.Journal) (*entities.Journal, error) <span class="cov0" title="0">{
        if err := r.db.Save(journal).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return journal, nil</span>
}

func (r *journalRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;entities.Journal{}, id).Error
}</span>

func (r *journalRepository) FindAll(page int, limit int) ([]entities.Journal, error) <span class="cov0" title="0">{
        var journals []entities.Journal
        offset := (page - 1) * limit
        if err := r.db.Preload("Author").Preload("Category").Limit(limit).Offset(offset).Find(&amp;journals).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return journals, nil</span>
}

func (r *journalRepository) FindByID(id uint) (*entities.Journal, error) <span class="cov0" title="0">{
        var journal entities.Journal
        if err := r.db.Preload("Author").Preload("Category").First(&amp;journal, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;journal, nil</span>
}

func (r *journalRepository) GetAuthorByID(id uint) (*entities.Author, error) <span class="cov0" title="0">{
        var author entities.Author
        if err := r.db.First(&amp;author, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;author, nil</span>
}

func (r *journalRepository) GetCategoryByID(id uint) (*entities.Category, error) <span class="cov0" title="0">{
        var category entities.Category
        if err := r.db.First(&amp;category, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;category, nil</span>
}

func (r *journalRepository) Count() (int64, error) <span class="cov0" title="0">{
        var count int64
        if err := r.db.Model(&amp;entities.Journal{}).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package mocks

import (
        "eco-journal/entities"

        "github.com/stretchr/testify/mock"
)

type AuthorRepo struct {
        mock.Mock
}

func (m *AuthorRepo) Create(author *entities.Author) (*entities.Author, error) <span class="cov8" title="1">{
        args := m.Called(author)
        return args.Get(0).(*entities.Author), args.Error(1)
}</span>

func (m *AuthorRepo) Update(author *entities.Author) (*entities.Author, error) <span class="cov8" title="1">{
        args := m.Called(author)
        return args.Get(0).(*entities.Author), args.Error(1)
}</span>

func (m *AuthorRepo) Delete(id uint) error <span class="cov8" title="1">{
        args := m.Called(id)
        return args.Error(0)
}</span>

func (m *AuthorRepo) FindByID(id uint) (*entities.Author, error) <span class="cov8" title="1">{
        args := m.Called(id)
        return args.Get(0).(*entities.Author), args.Error(1)
}</span>

func (m *AuthorRepo) FindAll(authors *[]entities.Author, page, limit int) error <span class="cov8" title="1">{
        args := m.Called(authors, page, limit)
        return args.Error(0)
}</span>

func (m *AuthorRepo) Count() (int64, error) <span class="cov8" title="1">{
        args := m.Called()
        return args.Get(0).(int64), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package mocks

import (
        "eco-journal/entities"

        "github.com/stretchr/testify/mock"
)

type CategoryRepo struct {
        mock.Mock
}

func (m *CategoryRepo) Create(category *entities.Category) (*entities.Category, error) <span class="cov8" title="1">{
        args := m.Called(category)
        return args.Get(0).(*entities.Category), args.Error(1)
}</span>

func (m *CategoryRepo) Update(category *entities.Category) (*entities.Category, error) <span class="cov8" title="1">{
        args := m.Called(category)
        return args.Get(0).(*entities.Category), args.Error(1)
}</span>

func (m *CategoryRepo) Delete(id uint) error <span class="cov8" title="1">{
        args := m.Called(id)
        return args.Error(0)
}</span>

func (m *CategoryRepo) FindByID(id uint) (*entities.Category, error) <span class="cov8" title="1">{
        args := m.Called(id)
        return args.Get(0).(*entities.Category), args.Error(1)
}</span>

func (m *CategoryRepo) FindAll(categories *[]entities.Category, page, limit int) error <span class="cov8" title="1">{
        args := m.Called(categories, page, limit)
        return args.Error(0)
}</span>

func (m *CategoryRepo) Count() (int64, error) <span class="cov8" title="1">{
        args := m.Called()
        return args.Get(0).(int64), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "eco-journal/entities"

        "gorm.io/gorm"
)

type UserRepoInterface interface {
        Create(user *entities.User) (*entities.User, error)
        FindByEmail(email string) (*entities.User, error)
}

type userRepository struct {
        db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *userRepository <span class="cov0" title="0">{
        return &amp;userRepository{db}
}</span>

func (r *userRepository) Create(user *entities.User) (*entities.User, error) <span class="cov0" title="0">{
        if err := r.db.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (r *userRepository) FindByEmail(email string) (*entities.User, error) <span class="cov0" title="0">{
        var user entities.User
        if err := r.db.Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package route

import (
        "eco-journal/controller"
        "eco-journal/middleware"

        "github.com/gin-gonic/gin"
)

func SetupRouter(
        userController *controller.UserController,
        authorController *controller.AuthorController,
        categoryController *controller.CategoryController,
        journalController *controller.JournalController,
        chatController *controller.ChatController) *gin.Engine <span class="cov0" title="0">{
        r := gin.Default()

        r.POST("/register", userController.Register)
        r.POST("/login", userController.Login)

        categoryRoutes := r.Group("/categories")
        categoryRoutes.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                categoryRoutes.GET("/", categoryController.GetAll)
                categoryRoutes.GET("/:id", categoryController.GetDetails)
                categoryRoutes.POST("/", categoryController.Create)
                categoryRoutes.PUT("/:id", categoryController.Update)
                categoryRoutes.DELETE("/:id", categoryController.Delete)
        }</span>

        <span class="cov0" title="0">authorRoutes := r.Group("/authors")
        authorRoutes.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                authorRoutes.GET("/", authorController.GetAll)
                authorRoutes.GET("/:id", authorController.GetDetails)
                authorRoutes.POST("/", authorController.Create)
                authorRoutes.PUT("/:id", authorController.Update)
                authorRoutes.DELETE("/:id", authorController.Delete)
        }</span>

        <span class="cov0" title="0">journalRoutes := r.Group("/journals")
        journalRoutes.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                journalRoutes.GET("/", journalController.GetAll)
                journalRoutes.GET("/:id", journalController.GetDetails)
                journalRoutes.POST("/", journalController.Create)
                journalRoutes.PUT("/:id", journalController.Update)
                journalRoutes.DELETE("/:id", journalController.Delete)
        }</span>

        <span class="cov0" title="0">chatRoutes := r.Group("/chat")
        chatRoutes.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                chatRoutes.GET("", chatController.GetAllChats)
                chatRoutes.POST("", chatController.ChatController)
        }</span>

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "eco-journal/entities"
        "eco-journal/repository"
)

type AuthorServiceInterface interface {
        Create(author *entities.Author) (*entities.Author, error)
        Update(author *entities.Author) (*entities.Author, error)
        Delete(id uint) error
        GetAll(page, limit int) ([]entities.Author, *entities.Pagination, error)
        FindByID(id uint) (*entities.Author, error)
}

type authorService struct {
        authorRepo repository.AuthorRepoInterface
}

func NewAuthorService(authorRepo repository.AuthorRepoInterface) *authorService <span class="cov8" title="1">{
        return &amp;authorService{authorRepo}
}</span>

func (s *authorService) Create(author *entities.Author) (*entities.Author, error) <span class="cov8" title="1">{
        return s.authorRepo.Create(author)
}</span>

func (s *authorService) Update(author *entities.Author) (*entities.Author, error) <span class="cov8" title="1">{
        return s.authorRepo.Update(author)
}</span>

func (s *authorService) Delete(id uint) error <span class="cov8" title="1">{
        return s.authorRepo.Delete(id)
}</span>

func (s *authorService) GetAll(page, limit int) ([]entities.Author, *entities.Pagination, error) <span class="cov8" title="1">{
        var authors []entities.Author

        totalItems, err := s.authorRepo.Count()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if err := s.authorRepo.FindAll(&amp;authors, page, limit); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">totalPages := int((totalItems + int64(limit) - 1) / int64(limit))

        pagination := &amp;entities.Pagination{
                CurrentPage: page,
                TotalPages:  totalPages,
                TotalItems:  totalItems,
        }

        return authors, pagination, nil</span>
}

func (s *authorService) FindByID(id uint) (*entities.Author, error) <span class="cov8" title="1">{
        return s.authorRepo.FindByID(id)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "eco-journal/entities"
        "eco-journal/repository"
)

type CategoryServiceInterface interface {
        Create(category *entities.Category) (*entities.Category, error)
        Update(category *entities.Category) (*entities.Category, error)
        Delete(id uint) error
        GetAll(page, limit int) ([]entities.Category, *entities.Pagination, error)
        FindByID(id uint) (*entities.Category, error)
}

type categoryService struct {
        categoryRepo repository.CategoryRepoInterface
}

func NewCategoryService(categoryRepo repository.CategoryRepoInterface) *categoryService <span class="cov8" title="1">{
        return &amp;categoryService{categoryRepo}
}</span>

func (s *categoryService) Create(category *entities.Category) (*entities.Category, error) <span class="cov8" title="1">{
        return s.categoryRepo.Create(category)
}</span>

func (s *categoryService) Update(category *entities.Category) (*entities.Category, error) <span class="cov8" title="1">{
        return s.categoryRepo.Update(category)
}</span>

func (s *categoryService) Delete(id uint) error <span class="cov8" title="1">{
        return s.categoryRepo.Delete(id)
}</span>

func (s *categoryService) GetAll(page, limit int) ([]entities.Category, *entities.Pagination, error) <span class="cov8" title="1">{
        var categories []entities.Category

        totalItems, err := s.categoryRepo.Count()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if err := s.categoryRepo.FindAll(&amp;categories, page, limit); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">totalPages := int((totalItems + int64(limit) - 1) / int64(limit))

        pagination := &amp;entities.Pagination{
                CurrentPage: page,
                TotalPages:  totalPages,
                TotalItems:  totalItems,
        }

        return categories, pagination, nil</span>
}

func (s *categoryService) FindByID(id uint) (*entities.Category, error) <span class="cov8" title="1">{
        return s.categoryRepo.FindByID(id)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "context"
        "eco-journal/entities"
        "eco-journal/repository"
        "fmt"
        "os"

        "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
)

type ChatServiceInterface interface {
        ProccessChat(userInput string) (entities.Chat, error)
        GetAllChats() ([]entities.Chat, error)
}

type chatService struct {
        chatRepo repository.ChatRepoInterface
}

func NewChatService(chatRepo repository.ChatRepoInterface) *chatService <span class="cov0" title="0">{
        return &amp;chatService{chatRepo}
}</span>

func (cuc *chatService) ProccessChat(userInput string) (entities.Chat, error) <span class="cov0" title="0">{
        ctx := context.Background()
        client, err := genai.NewClient(ctx, option.WithAPIKey(os.Getenv("GEMINI_API_KEY")))
        if err != nil </span><span class="cov0" title="0">{
                return entities.Chat{}, err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        model := client.GenerativeModel("gemini-1.5-flash")
        resp, err := model.GenerateContent(ctx, genai.Text(userInput))
        if err != nil </span><span class="cov0" title="0">{
                return entities.Chat{}, err
        }</span>
        <span class="cov0" title="0">if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                return entities.Chat{}, err
        }</span>
        <span class="cov0" title="0">aiResponse := ""
        for _, candidate := range resp.Candidates </span><span class="cov0" title="0">{
                if candidate.Content == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, part := range candidate.Content.Parts </span><span class="cov0" title="0">{
                        aiResponse += fmt.Sprintf("%v", part)
                }</span>
        }
        <span class="cov0" title="0">chat := entities.Chat{
                UserInput: userInput,
                AiRespon:  aiResponse,
        }
        if err := cuc.chatRepo.SaveChat(chat); err != nil </span><span class="cov0" title="0">{
                return entities.Chat{}, err
        }</span>

        <span class="cov0" title="0">return chat, nil</span>

}

func (cts *chatService) GetAllChats() ([]entities.Chat, error) <span class="cov0" title="0">{
        return cts.chatRepo.GetAllChat()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "eco-journal/entities"
        "eco-journal/repository"
)

type JournalServiceInterface interface {
        Create(journal *entities.Journal) (*entities.Journal, error)
        Update(journal *entities.Journal) (*entities.Journal, error)
        Delete(id uint) error
        GetAll(page int, limit int) ([]entities.Journal, error)
        FindByID(id uint) (*entities.Journal, error)
        GetAuthorByID(id uint) (*entities.Author, error)
        GetCategoryByID(id uint) (*entities.Category, error)
        Count() (int64, error)
}

type journalService struct {
        journalRepo repository.JournalRepoInterface
}

func NewJournalService(journalRepo repository.JournalRepoInterface) *journalService <span class="cov0" title="0">{
        return &amp;journalService{journalRepo}
}</span>

func (s *journalService) Create(journal *entities.Journal) (*entities.Journal, error) <span class="cov0" title="0">{
        return s.journalRepo.Create(journal)
}</span>

func (s *journalService) Update(journal *entities.Journal) (*entities.Journal, error) <span class="cov0" title="0">{
        return s.journalRepo.Update(journal)
}</span>

func (s *journalService) Delete(id uint) error <span class="cov0" title="0">{
        return s.journalRepo.Delete(id)
}</span>

func (s *journalService) GetAll(page int, limit int) ([]entities.Journal, error) <span class="cov0" title="0">{
        return s.journalRepo.FindAll(page, limit)
}</span>

func (s *journalService) FindByID(id uint) (*entities.Journal, error) <span class="cov0" title="0">{
        return s.journalRepo.FindByID(id)
}</span>

func (s *journalService) GetAuthorByID(id uint) (*entities.Author, error) <span class="cov0" title="0">{
        return s.journalRepo.GetAuthorByID(id)
}</span>

func (s *journalService) GetCategoryByID(id uint) (*entities.Category, error) <span class="cov0" title="0">{
        return s.journalRepo.GetCategoryByID(id)
}</span>

func (s *journalService) Count() (int64, error) <span class="cov0" title="0">{
        return s.journalRepo.Count()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "eco-journal/entities"
        "eco-journal/middleware"
        "eco-journal/repository"

        "golang.org/x/crypto/bcrypt"
)

type UserServiceInterface interface {
        Register(user *entities.User) (*entities.User, error)
        Login(email, password string) (string, error)
}

type userService struct {
        userRepo repository.UserRepoInterface
}

func NewUserService(userRepo repository.UserRepoInterface) *userService <span class="cov0" title="0">{
        return &amp;userService{userRepo}
}</span>

func (s *userService) Register(user *entities.User) (*entities.User, error) <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">user.Password = string(hashedPassword)
        return s.userRepo.Create(user)</span>
}

func (s *userService) Login(email, password string) (string, error) <span class="cov0" title="0">{
        user, err := s.userRepo.FindByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">token, err := middleware.GenerateToken(user.Username)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return token, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
